#!/bin/bash
# 注意：我們故意移除了 'set -e'，以防止任何意外的熔斷

WORKER_SCRIPT="src/shell/worker.sh"
LOCK_FILE="logs/.worker.lock"

echo "================================================="
echo "  「工人腳本 (worker.sh)」併發鎖手動驗收"
echo "================================================="
echo
echo "--- 測試場景：模擬併發衝突 ---"
echo "  [步驟 1]: 正在後台啟動一個『慢工人』，它將持有鎖 5 秒鐘..."

# 為了確保測試環境乾淨，先刪除可能存在的舊鎖文件
rm -f "$LOCK_FILE"

# 在後台啟動一個模擬的「慢工人」
# 它會鎖住文件，並在 5 秒後自動釋放鎖並退出
(
    flock 200
    echo "    (後台日誌：『慢工人』已獲取鎖，開始休眠...)"
    sleep 5
    echo "    (後台日誌：『慢工人』休眠結束，釋放鎖。)"
) 200>"$LOCK_FILE" &

# 給「慢工人」一點時間，確保它能成功啟動並獲取鎖
sleep 1

echo "  [步驟 2]: 『慢工人』已在後台運行。現在，我們嘗試啟動一個『快工人』..."
echo "  (預期結果：『快工人』應立刻失敗，並打印『獲取鎖失敗』的錯誤訊息)"
echo "-------------------------------------------------"

# 執行我們的「快工人」（worker.sh）
# 我們用一個假的、無意義的輸入，因為我們只關心它是否被鎖住
echo "無意義的輸入" | bash "$WORKER_SCRIPT" "/tmp" "/tmp/doc"

echo "-------------------------------------------------"
echo "  > 『快工人』指令執行完畢。"
echo
echo "================================================="
echo "  驗收結束。"
echo "  請您親眼判斷，上方是否打印出了『獲取鎖失敗』的錯誤訊息？"
echo "  (等待約 4 秒，讓後台的『慢工人』結束...)"
echo "================================================="

# 等待後台的「慢工人」進程結束，以保持終端乾淨
wait
